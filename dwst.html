<!DOCTYPE html>
<!--
Dark WebSocket Terminal

CC0, http://creativecommons.org/publicdomain/zero/1.0/

To the extent possible under law, Dark WebSocket Terminal developers have waived all copyright and related or neighboring rights to Dark WebSocket Terminal.

Dark WebSocket Terminal developers:
Toni Ruottu <toni.ruottu@iki.fi>, Finland 2010-2012

-->
<html>
<head>
<title>Dark WebSocket Terminal</title>
<script>

var ws = {};
var intervalId = null;
var VERSION = '1.1.6';

function Interval() {}
Interval.prototype.commands = function() {
  return ['interval'];
}
Interval.prototype.help = function() {
  return ['usage: /interval <interval> [message]','       /interval'];
}
Interval.prototype.run = function(params) {
  if (params.length < 1) {
    if (intervalId != null) {
      clearInterval(intervalId);
      log('interval cleared', 'system');
    } else {
      log('no interval to clear', 'error');
    }
    return;
  }
  var count = 0;
  var first = params.shift();
  var interval = parseInt(first, 10);
  var spammer = function() {
    if (!isconnected()) {
      if (intervalId != null) {
        log('interval failed, no connection', 'error');
        run('interval');
      }
      return;
    }
    if (params.length < 1) {
      run('send', ['' + count]);
      count += 1;
      return;
    }
    run('send', params);
  }
  if (intervalId != null) {
    log('clearing old interval', 'system');
    clearInterval(intervalId);
  }
  intervalId = setInterval(spammer, interval);
  log('interval set', 'system');
}

function Spam() {}
Spam.prototype.commands = function() {
  return ['spam'];
}
Spam.prototype.help = function() {
  return ['usage: /spam <times> [message]'];
}
Spam.prototype.run = function(params) {
  var times = params.shift();
  function spam(limit, i) {
    if (typeof(i) == typeof(undefiend)) {
      i = 0;
    }
    if (i == limit) {
      return;
    }
    if (params.length < 1) {
      run('send', ['' + i]);
    } else {    
      run('send', params);
    }
    var nextspam = function() {
      spam(limit, i + 1);
    }
    setTimeout(nextspam, 0)
  }
  spam(times);
}

function Send() {}
Send.prototype.commands = function() {
  return ['send',''];
}
Send.prototype.run = function(params) {
  var msg = params.join(' ');
  if (typeof(ws.readyState) == typeof(undefined) || ws.readyState > 1) { //CLOSING or CLOSED
    mlog(['no connection', 'cannot send: ' + msg, 'connect first with /connect'], 'error');
    return;
  }
  log(msg, "sent");
  ws.send(msg);
}

function Binary() {}
Binary.prototype.commands = function() {
  return ['binary','b'];
}
Binary.prototype.run = function(params) {
  var msg = params.join(' ');
  function byteValue(x) {
    return x.charCodeAt(0) & 0xff;
  }
  var ords = Array.prototype.map.call(msg, byteValue);
  var ords = [];
  for (var i = 0; i <= 0xff; i++) {
    ords.push(i);
  }
  var ui8a = new Uint8Array(ords);
  if (typeof(ws.readyState) == typeof(undefined) || ws.readyState > 1) { //CLOSING or CLOSED
    mlog(['no connection', 'cannot send: ' + msg, 'connect first with /connect'], 'error');
    return;
  }
  bmlog(ui8a.buffer, "sent");
  ws.send(ui8a.buffer);
}

function Help() {}
Help.prototype.commands = function() {
  return ['help'];
}
Help.prototype.run = function(params) {
  for (var i in params) {
    var command = params[i];
    var plugin = commands[command];
    if (typeof(plugin) == typeof(undefined)) {
      log('the command does not exist: ' + command, 'error');
      return;
    }
    if (typeof(plugin.help) == typeof(undefined))
    {
      log(['no help available for: ' + command], 'system');
      return;
    }
    mlog(plugin.help(), 'system');
    return;
  }
  var available = [];
  for (var c in commands) {
    if (c.length > 0) {
      available.push(c);
    }
  }
  available.sort();
  mlog(['Dark WebSocket Terminal ' + VERSION, 'available commands: ' + available.join(', '), 'for help on a command use: /help <command>'], 'system');
}

function Connect() {}
Connect.prototype.commands = function() {
  return ['connect'];
}
Connect.prototype.help = function() {
  return ['Usage: /connect <ws-url> [protocol]'];
}
Connect.prototype.run = function(params) {
  var url = params[0];
  var proto = params[1];
  var protostring = ''
  document.getElementById('conbut1').setAttribute('onclick', "guidisconnect();");
  document.getElementById('conbut1').value = "disconnect";
  document.getElementById('url1').setAttribute("disabled", "disabled");
  document.getElementById('proto1').setAttribute("disabled", "disabled");
  if(proto == '') {
    ws = new WebSocket(url);
  }
  else {
    ws = new WebSocket(url,proto);
    protostring = " (protocol: " + proto + ")"
  }
  history.replaceState({}, "", "?socket=" + url + '&proto=' + proto + '&connected=true');
  ws.onopen = function() {
    log("connection established, " + url + protostring, "system");
  };
  ws.onclose = function() {
    log("connection closed, " + url + protostring, "system");
  };
  ws.onmessage = function(msg) {
    if (typeof(msg.data) == typeof('')) {
      log(msg.data, "received");
    }
    else {
      var fr = new FileReader();
      fr.onload = function(e) {
        var buffer = e.target.result;
        bmlog(buffer, "received");
      }
      fr.readAsArrayBuffer(msg.data);
    }

  };
  ws.onerror = function() {
    log('websocket error: ' + url + ' ' + protostring, "system");
  };
}

function Disconnect() {}
Disconnect.prototype.commands = function() {
  return ['disconnect'];
}
Disconnect.prototype.help = function() {
  return ["Disconnects from the server. (usage: /disconnect)"];
}
Disconnect.prototype.run = function()
{
  var url = document.getElementById('url1').value;
  var proto = document.getElementById('proto1').value;
  document.getElementById('conbut1').setAttribute('onclick', "guiconnect();");
  document.getElementById('conbut1').value = "connect";
  document.getElementById('url1').removeAttribute("disabled");
  document.getElementById('proto1').removeAttribute("disabled");
  history.replaceState({}, "", "?socket=" + url + '&proto=' + proto + '&connected=false');
  ws.close();
  document.getElementById('url1').focus();
}

var plugins = [Connect, Disconnect, Help, Send, Spam, Interval, Binary];
var commands = {}

for (var i in plugins) {
  var constructor = plugins[i];
  var plugin = new constructor();
  var c = plugin.commands();
  for (var j in c) {
    var command = c[j];
    commands[command] = plugin;
  }
}

function process(param) {
  return param;
}

function run(command, params) {
  if (typeof(params) == typeof(undefined)){
    params = [];
  }
  var plugin = commands[command];
  if (typeof(plugin) == typeof(undefined)) {
    log('invalid command: ' + command, 'error');
    return;
  }
  var processed = Array.prototype.map.call(params, process);
  plugin.run(processed);
}


function refreshclock() {
  var time = currenttime();
  document.getElementById('clock1').innerHTML = time;
}

function currenttime() {
  addzero = function(i) {
    if (i < 10) {
      return "0"+i;
    }
    return ""+i;
  };
  var date = new Date();
  return time = addzero(date.getHours()) +":"+ addzero(date.getMinutes())+'<span class="sec">:'+ addzero(date.getSeconds())+'</span>';

}

function htmlescape(line) {
  return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function log(line, type) {
  mlog([line], type);
}

function mlog(lines, type, binary) {
  binclass = '';
  if (binary == true) {
    binclass = ' binary';
  }
  var escaped = Array.prototype.map.call(lines, htmlescape);
  var time = currenttime();
  document.getElementById('ter1').innerHTML += '<tr class="logline"><td class="time">'+time+'</td><td class="direction '+type+'">'+type+':</td><td class="preserved' + binclass + '">'+escaped.join('<br />')+'</td></tr>';
  var screen = document.getElementById("screen1");
  screen.scrollTop = screen.scrollHeight;
}

function divissimo(l, n) {
  var chunks = [];
  var chunk = [];
  var i = 0;
  for (var j in l) {
    b = l[j];
    if (i >= n) {
      chunks.push(chunk);
      chunk = [];
      i = 0;
    }
    chunk.push(b);
    i += 1;
  }
  chunks.push(chunk);
  return chunks;
}

function bmlog(buffer, type) {
  var dv = new DataView(buffer);
  var bytes = [];
  for (var i = 0; i < buffer.byteLength; i++) {
      bytes.push(dv.getUint8(i));
  }
  var parts = divissimo(bytes, 8);
  var rows = divissimo(parts, 2);
  function prow(row) {
    function hexify(num) {
      var hex = num.toString(16);
      var zero = hex.length < 2 ? '0' : ''
      return zero + hex;
    }
    function charify(num) {
      if (num > 0x7e || num < 0x20) { // non-printable
        return '.';
      }
      return String.fromCharCode(num);
    }
    var s = row[0];
    var e = row[1];
    var sh = Array.prototype.map.call(s, hexify);


    var sc = Array.prototype.map.call(s, charify);
    ec = [];
    eh = [];
    if (e) {
      var ec = Array.prototype.map.call(e, charify);
      var eh = Array.prototype.map.call(e, hexify);
    }
    var hexed =  sh.join(' ') + '  ' + eh.join(' ')
    var chars =  sc.join('') + ' ' + ec.join('')
    var hexpad = Array(49 - hexed.length).join(" ")
    var charpad = Array(18 - chars.length).join(" ")
    return hexed + hexpad + ' ' + '|' + chars + charpad + '|';
  }
  var prows = Array.prototype.map.call(rows, prow);

  mlog(prows, type, true);
}

function lol(line) {
  log(line, 'command');
  var noslash = line.substring(1);
  var parts = noslash.split(' ');
  var command = parts.shift();
  var params = parts;
  run(command, params);
}

function send() {
  var raw = document.getElementById('msg1').value;
  document.getElementById('msg1').value = "";
  if (raw.length < 1) {
    log('type /help to list available commands', 'system');
    return;
  }
  if (raw[0] == '/') {
    lol(raw);
    return ;
  }
  lol('/send ' + raw);
  return ;
}


function Menu() {}
Menu.prototype.isopen = function() {
  return (document.getElementById('open').getAttribute("style") == null)
}

Menu.prototype.hide = function() {
  document.getElementById('open').setAttribute("style", "visibility: hidden;");
  document.getElementById('msg1').focus();
  document.getElementById('sendbut1').removeAttribute("disabled");
  document.getElementById('menubut1').removeAttribute("class");
}

Menu.prototype.show = function() {
  document.getElementById('open').removeAttribute("style");
  document.getElementById('url1').focus();
  document.getElementById('sendbut1').setAttribute("disabled", "disabled");
  document.getElementById('menubut1').setAttribute("class", "active");
}

Menu.prototype.toggle = function() {
  if (this.isopen()) {
    menu.hide();
  } else {
    menu.show();
  }
}
menu = new Menu();

function guidisconnect() {
  lol('/disconnect');

}

function guiconnect() {
  menu.hide();
  var url = document.getElementById('url1').value;
  var proto = document.getElementById('proto1').value;
  lol('/connect ' + url + ' ' + proto);
}

function keypress() {
  if (event.keyCode == 13) {
    if (menu.isopen()) {
      if (isconnected()) {
        return true;
      }
      document.getElementById('conbut1').click()
    } else {
      document.getElementById('sendbut1').click()
    }
  } else if (event.keyIdentifier == 'U+001B') {
    if (typeof(ws.readyState) == typeof(undefined)) {
      menu.toggle();
    } else if (ws.readyState < 2) { // OPEN or CONNECTING
      guidisconnect();
    } else {
      menu.toggle();
    }
  }
}

function isconnected() {
  if (typeof(ws.readyState) == typeof(undefined)) {
    return false;
  }
  if (ws.readyState == 1) {
    return true;
  }
  return false;
}

function linkfix() {
  document.getElementById("sourcelink").setAttribute("href","view-source:"+location.href);
}

function parseParams() {
    var query = window.location.href.split('?')[1];
    if (query !== undefined) {
        var defs = query.split('&');
    }
    var params = {}
    for (var i in defs) {
        var parts = defs[i].split("=");
        params[parts[0]] = parts[1];
    }
    return params;
}

function init() {
  var params = parseParams();
  var connected = params.connected;
  var socket = params.socket;
  var proto = params.proto;

  linkfix();
  if (proto) {
      document.getElementById('proto1').value = proto
  }
  if (socket) {
      document.getElementById('url1').value = socket
  }
  refreshclock();
  document.getElementById('clock1').removeAttribute("style");
  setInterval( "refreshclock();", 500 );
  if (("WebSocket" in window) == false) {
    log('Your browser does not seem to support websockets.', 'error');
    return;
  }
  lol('/help');
  if(connected == "true")
  {
    document.getElementById('conbut1').click()
  }
  else
  {
    menu.show();
  }
}

</script>

<style>

body
{
  height: 100%;
  background-color: #540;
}
h1 a
{
  padding: 0;
  color: #000;
  font-family: serif;
}
.button
{
  width: 3em;
}
.direction
{
  width: 3em;
  text-align: right;
}

.sent
{
  color: #77c;
}

.received
{
  color: #c77;
}

.command
{
  color: #3ef;
}

.error
{
  color: #f00;
}

.system
{
  color: #7f7;
}

.time
{
  width: 3em;
}

.sec
{
  color: #777;
}

.label
{
  width: 1em;
}

.protofield
{
  width: 15%;
}

h1 a
{
  color: #aaa;
  font-family: sans-serif;
  text-decoration: none;

}

h1
{
  text-align: center;
}
.footer
{
  margin-top: 4em;
  text-align: center;
  font-size: 0.4em;
  font-family: sans-serif;
  color: #ddd;
  padding: 1em;
}

.footer a
{
  color: #ddf;
}
.footer img
{
  width: 5em;
  height: 1.8em;
  padding-right: 1em;
}

table.terminal
{
  background-color: #000;
  color: #ccc;
  font-family: monospace;
}
input[type="text"]
{
  background-color: #444;
  color: #fff;
  font-family: monospace;
  border: thin solid #f00;
}

input[readonly="readonly"]
{
  background-color: #555;
  color: #ddd;

}

#open input[type="text"]
{
  border: thin solid #000;
  width: 100%;
}
.bar2 input[type="text"]
{
  border: thin solid #000;
  width: 100%;
}

.consolebar input[type="button"]
{
  padding: 0;
  width: 5em;
}

body
{
  margin: 0;
}
.logline td
{
  vertical-align: top;
}
.preserved {
  white-space: pre;
}

.consolebar
{
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 2em;
  background-color: #222;
}

.consolebar .time
{
  font-family: monospace;
  width: 1em;
  color: #ddd;
}

.consolebar .leftpad
{
  padding-left: 1em;
}

.consolebar .rightpad
{
  padding-right: 1em;
}

#screen1
{
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 2em;
  background-color: #000;
  overflow: auto;
  vertical-align: top;
}

#open
{
  background-color: rgba(85, 68, 0, 0.8);
  color: #777;
  border-radius: 15px;
  position: absolute;
  margin: 10%;
  width: 80%;
  border: medium solid #777;
  text-align: center;
  font-family: sans-serif;
  font-size: 0.8em;
}
.bar2
{
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 2em;
}
.panel
{
  border: medium solid #540;
  border-radius: 5px;
  padding: 1em;
  margin: auto 10%;
  width: 80%;
  background-color: #320;
  text-align: right;
}
.panel .label
{
  width: 3em;
}
.binary
{
  color: #888;
}
</style>
</head>
<body onload="init();" onkeydown="keypress();">
<div id="screen1" class="screen">
<table id="ter1" class="terminal">
</table>
</div>
<div class="bar2">
<table class="consolebar"><tr>
<td id="clock1" style="color: transparent;" class="time rightpad leftpad">00:00:00</td>
<td><input id="msg1" type="text" value=""></td>
<td class="button rightpad"><input id="sendbut1" type="button" value="send" disabled="disabled" onClick="send();"></td>
<td class="button rightpad"><input id="menubut1" type="button" value="menu" onClick="menu.toggle();"></td>
</tr></table>
</div>

<div id="open" style="visibility: hidden;">
<h1><a href="?">Dark WebSocket Terminal</a></h1>
<table class="panel">
<tr><td class="label">socket:</td><td><input type="text" id="url1" value="ws://echo.websocket.org/"></td></tr>
<tr><td>protocol:</td><td><input type="text" id="proto1" value=""></td></tr>
<tr><td colspan="2"><input id="conbut1" type="button" value="connect" onClick="guiconnect();"></td></tr>
</table>

<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#" class="footer"> 
  <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/"> 
    <img src="http://i.creativecommons.org/l/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" /></a> 

  To the extent possible under law, <a id="sourcelink" href="" rel="dct:publisher"><span property="dct:title">Dark WebSocket Terminal developers</span></a> 
  have waived all copyright and related or neighboring rights to
  <span property="dct:title">Dark WebSocket Terminal</span>.
</p>
</div>

</body>
</html>
