<!DOCTYPE html>
<!--
Dark WebSocket Terminal

CC0, http://creativecommons.org/publicdomain/zero/1.0/

To the extent possible under law, Dark WebSocket Terminal developers have waived all copyright and related or neighboring rights to Dark WebSocket Terminal.

Dark WebSocket Terminal developers:
Toni Ruottu <toni.ruottu@iki.fi>, Finland 2010-2012

-->
<html>
<head>
<title>Dark WebSocket Terminal</title>
<script>

var ws = {};
var intervalId = null;
var VERSION = '1.1.6';
var vars = {};

function Loadfile() {}
Loadfile.prototype.commands = function() {
  return ['loadfile'];
}
Loadfile.prototype.help = function() {
  return ['usage: /loadfile <variable>'];
}
Loadfile.prototype.run = function(params) {
      var variable = params[0];
      var upload = document.getElementById('file1');
      upload.onchange = function(e) {
        var file = upload.files[0];
        reader = new FileReader();
        reader.onload = function(e2) {
          var buffer = e2.target.result;
          vars[variable] = buffer;
          log('file ' + file.fileName + ' (' + buffer.byteLength + 'B)' + ' loaded to ' + variable, 'system');
        };
        reader.readAsArrayBuffer(file);
      }
      upload.click();
}

function Interval() {}
Interval.prototype.commands = function() {
  return ['interval'];
}
Interval.prototype.help = function() {
  return ['usage: /interval <interval> [message]','       /interval'];
}
Interval.prototype.run = function(params) {
  if (params.length < 1) {
    if (intervalId != null) {
      clearInterval(intervalId);
      log('interval cleared', 'system');
    } else {
      log('no interval to clear', 'error');
    }
    return;
  }
  var count = 0;
  var first = params.shift();
  var interval = parseInt(first, 10);
  var spammer = function() {
    if (!isconnected()) {
      if (intervalId != null) {
        log('interval failed, no connection', 'error');
        run('interval');
      }
      return;
    }
    if (params.length < 1) {
      run('send', ['' + count]);
      count += 1;
      return;
    }
    run('send', params);
  }
  if (intervalId != null) {
    log('clearing old interval', 'system');
    clearInterval(intervalId);
  }
  intervalId = setInterval(spammer, interval);
  log('interval set', 'system');
}

function Spam() {}
Spam.prototype.commands = function() {
  return ['spam'];
}
Spam.prototype.help = function() {
  return ['usage: /spam <times> [message]'];
}
Spam.prototype.run = function(params) {
  var times = params.shift();
  function spam(limit, i) {
    if (typeof(i) == typeof(undefiend)) {
      i = 0;
    }
    if (i == limit) {
      return;
    }
    if (params.length < 1) {
      run('send', ['' + i]);
    } else {    
      run('send', params);
    }
    var nextspam = function() {
      spam(limit, i + 1);
    }
    if (isconnected()) {
      setTimeout(nextspam, 0)
    } else {
        log('spam failed, no connection', 'error');
    }
  }
  spam(times);
}

function Send() {}
Send.prototype.commands = function() {
  return ['send',''];
}
Send.prototype.run = function(params) {
  function process(par) {
    var end = '';
    if (par[par.length - 1] == '\\') {
      end = ' ';
      par =  par.substr(0, par.length - 1);
    }
    if (par.substr(0,2) == '\\[') {
      out =  par.substr(1);
    } else if (par.match(/^\[random\(/) != null) {
      function randomchar() {
        var out = Math.floor(Math.random()* (0xffff + 1));
        out /= 2; // avoid risky characters
        var char = String.fromCharCode(out);
        return char;
      }
      var num = parseInt(par.substring(8, par.length - 2), 10);
      var str = '';
      for (var i = 0; i < num; i++) {
        str += randomchar();
      }
      out = str;      
    } else {
      out = par;
    }
    return out + end;
  }
  var processed = Array.prototype.map.call(params, process);
  var msg = processed.join('');
  if (typeof(ws.readyState) == typeof(undefined) || ws.readyState > 1) { //CLOSING or CLOSED
    mlog(['no connection', 'cannot send: ' + msg, 'connect first with /connect'], 'error');
    return;
  }
  log(msg, "sent");
  ws.send(msg);
}

function Binary() {}
Binary.prototype.commands = function() {
  return ['binary','b'];
}
Binary.prototype.run = function(params) {
  function byteValue(x) {
    return x.charCodeAt(0) & 0xff;
  }
  function hexpairtobyte(hp) {
    hex = hp.join('');
    if (hex.length != 2) {
      return;
    }
    return parseInt(hex, 16);
  }
  function binpara(par) {
    var bytes = [];
    if (par.match(/^\[var\(/) != null) {
      var variable = par.substring(5, par.length - 2);
      var buffer = vars[variable];
      return new Uint8Array(buffer);
    } else if (par.match(/^\[random\(/) != null) {
      function randombyte() {
        var out = Math.floor(Math.random()* (0xff + 1));
        return out;
      }
      var num = parseInt(par.substring(8, par.length - 2), 10);
      var bytes = [];
      for (var i = 0; i < num; i++) {
        bytes.push(randombyte());
      }
    } else if (par.match(/^\[0x/) != null) {
      var hex = par.substring(3, par.length - 1);
      var nums = hex.split('');
      var pairs = divissimo(nums, 2);
      tmp = Array.prototype.map.call(pairs, hexpairtobyte);
      bytes = tmp.filter(function(b){return typeof(b) == typeof(0);})
    } else {   
      bytes = Array.prototype.map.call(par, byteValue);
    }
    return new Uint8Array(bytes);
  }
  function joinbufs(buffers) {

    var total = 0;
    for (var i in buffers) {
      buffer = buffers[i];
      total += buffer.length;
    }
    var out = new Uint8Array(total);
    var offset = 0;
    for (var i in buffers) {
      buffer = buffers[i];
      out.set(buffer, offset);
      offset += buffer.length;
    }
    return out;
  }
  var buffers = Array.prototype.map.call(params, binpara);
  var out = joinbufs(buffers).buffer;
  var msg = params.join(' ');
  if (typeof(ws.readyState) == typeof(undefined) || ws.readyState > 1) { //CLOSING or CLOSED
    mlog(['no connection', 'cannot send: ' + msg, 'connect first with /connect'], 'error');
    return;
  }
  bmlog(out, "sent");
  ws.send(out);
}

function Help() {}
Help.prototype.commands = function() {
  return ['help'];
}
Help.prototype.run = function(params) {
  for (var i in params) {
    var command = params[i];
    var plugin = commands[command];
    if (typeof(plugin) == typeof(undefined)) {
      log('the command does not exist: ' + command, 'error');
      return;
    }
    if (typeof(plugin.help) == typeof(undefined))
    {
      log(['no help available for: ' + command], 'system');
      return;
    }
    mlog(plugin.help(), 'system');
    return;
  }
  var available = [];
  for (var c in commands) {
    if (c.length > 0) {
      available.push(c);
    }
  }
  available.sort();
  mlog(['Dark WebSocket Terminal ' + VERSION, 'available commands: ' + available.join(', '), 'for help on a command use: /help <command>'], 'system');
}

function Connect() {}
Connect.prototype.commands = function() {
  return ['connect'];
}
Connect.prototype.help = function() {
  return ['Usage: /connect <ws-url> [protocol]'];
}
Connect.prototype.run = function(params) {
  var url = params[0];
  var proto = params[1];
  var protostring = ''
  document.getElementById('conbut1').setAttribute('onclick', "guidisconnect();");
  document.getElementById('conbut1').value = "disconnect";
  document.getElementById('url1').setAttribute("disabled", "disabled");
  document.getElementById('proto1').setAttribute("disabled", "disabled");
  if(proto == '') {
    ws = new WebSocket(url);
  }
  else {
    ws = new WebSocket(url,proto);
    protostring = " (protocol: " + proto + ")"
  }
  history.replaceState({}, "", "?socket=" + url + '&proto=' + proto + '&connected=true');
  ws.onopen = function() {
    log("connection established, " + url + protostring, "system");
  };
  ws.onclose = function() {
    log("connection closed, " + url + protostring, "system");
  };
  ws.onmessage = function(msg) {
    if (typeof(msg.data) == typeof('')) {
      log(msg.data, "received");
    }
    else {
      var fr = new FileReader();
      fr.onload = function(e) {
        var buffer = e.target.result;
        bmlog(buffer, "received");
      }
      fr.readAsArrayBuffer(msg.data);
    }

  };
  ws.onerror = function() {
    log('websocket error: ' + url + ' ' + protostring, "system");
  };
}

function Disconnect() {}
Disconnect.prototype.commands = function() {
  return ['disconnect'];
}
Disconnect.prototype.help = function() {
  return ["Disconnects from the server. (usage: /disconnect)"];
}
Disconnect.prototype.run = function()
{
  var url = document.getElementById('url1').value;
  var proto = document.getElementById('proto1').value;
  document.getElementById('conbut1').setAttribute('onclick', "guiconnect();");
  document.getElementById('conbut1').value = "connect";
  document.getElementById('url1').removeAttribute("disabled");
  document.getElementById('proto1').removeAttribute("disabled");
  history.replaceState({}, "", "?socket=" + url + '&proto=' + proto + '&connected=false');
  ws.close();
  document.getElementById('url1').focus();
}

var plugins = [Connect, Disconnect, Help, Send, Spam, Interval, Binary, Loadfile];
var commands = {}

for (var i in plugins) {
  var constructor = plugins[i];
  var plugin = new constructor();
  var c = plugin.commands();
  for (var j in c) {
    var command = c[j];
    commands[command] = plugin;
  }
}


function run(command, params) {
  if (typeof(params) == typeof(undefined)){
    params = [];
  }
  var plugin = commands[command];
  if (typeof(plugin) == typeof(undefined)) {
    log('invalid command: ' + command, 'error');
    return;
  }
  plugin.run(params);
}


function refreshclock() {
  var time = currenttime();
  document.getElementById('clock1').innerHTML = time;
}

function currenttime() {
  addzero = function(i) {
    if (i < 10) {
      return "0"+i;
    }
    return ""+i;
  };
  var date = new Date();
  return time = addzero(date.getHours()) +":"+ addzero(date.getMinutes())+'<span class="sec">:'+ addzero(date.getSeconds())+'</span>';

}

function htmlescape(line) {
  return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function log(line, type) {
  mlog([line], type);
}

function mlog(lines, type, binary) {
  binclass = '';
  if (binary == true) {
    binclass = ' binary';
  }
  var escaped = Array.prototype.map.call(lines, htmlescape);
  var time = currenttime();
  document.getElementById('ter1').innerHTML += '<tr class="logline"><td class="time">'+time+'</td><td class="direction '+type+'">'+type+':</td><td class="preserved' + binclass + '">'+escaped.join('<br />')+'</td></tr>';
  var screen = document.getElementById("screen1");
  screen.scrollTop = screen.scrollHeight;
}

function divissimo(l, n) {
  var chunks = [];
  var chunk = [];
  var i = 0;
  for (var j in l) {
    b = l[j];
    if (i >= n) {
      chunks.push(chunk);
      chunk = [];
      i = 0;
    }
    chunk.push(b);
    i += 1;
  }
  chunks.push(chunk);
  return chunks;
}

function bmlog(buffer, type) {
  var dv = new DataView(buffer);
  var bytes = [];
  for (var i = 0; i < buffer.byteLength; i++) {
      bytes.push(dv.getUint8(i));
  }
  var parts = divissimo(bytes, 8);
  var rows = divissimo(parts, 2);
  function prow(row) {
    function hexify(num) {
      var hex = num.toString(16);
      var zero = hex.length < 2 ? '0' : ''
      return zero + hex;
    }
    function charify(num) {
      if (num > 0x7e || num < 0x20) { // non-printable
        return '.';
      }
      return String.fromCharCode(num);
    }
    var s = row[0];
    var e = row[1];
    var sh = Array.prototype.map.call(s, hexify);


    var sc = Array.prototype.map.call(s, charify);
    ec = [];
    eh = [];
    if (e) {
      var ec = Array.prototype.map.call(e, charify);
      var eh = Array.prototype.map.call(e, hexify);
    }
    var hexed =  sh.join(' ') + '  ' + eh.join(' ')
    var chars =  sc.join('') + ' ' + ec.join('')
    var hexpad = Array(49 - hexed.length).join(" ")
    var charpad = Array(18 - chars.length).join(" ")
    return hexed + hexpad + '  ' + '|' + chars + charpad + '|';
  }
  var prows = Array.prototype.map.call(rows, prow);
  var offset = 0;
  for (var i in prows) {
    num = offset.toString(16);
    var pad = Array(8 - num.length).join("0")
    prows[i] = pad + num + '  ' + prows[i];
    offset += 16;
  }
  mlog(prows, type, true);
}

function lol(line) {
  log(line, 'command');
  var noslash = line.substring(1);
  var parts = noslash.split(' ');
  var command = parts.shift();
  var params = parts;
  run(command, params);
}

function send() {
  var raw = document.getElementById('msg1').value;
  document.getElementById('msg1').value = "";
  if (raw.length < 1) {
    log('type /help to list available commands', 'system');
    return;
  }
  if (raw[0] == '/') {
    lol(raw);
    return ;
  }
  var korvailut = [['[','\\['], [' ','\\ ']];

  function korvaile(str, kor) {
    if (kor.length < 1) {
      return str;
    }
    var head = kor[0];
    var find = head[0];
    var rep = head[1];

    var parts = str.split(find);
    var complete = []
    for (var i in parts) {
      var part = parts[i];
      var loput = kor.slice(1)
      var news = korvaile(part, loput);
      complete.push(news);
    }
    var out = complete.join(rep);
    return(out);
  }

  lol('/send ' + korvaile(raw, korvailut));
  return ;
}


function Menu() {}
Menu.prototype.isopen = function() {
  return (document.getElementById('open').getAttribute("style") == null)
}

Menu.prototype.hide = function() {
  document.getElementById('open').setAttribute("style", "visibility: hidden;");
  document.getElementById('msg1').focus();
  document.getElementById('sendbut1').removeAttribute("disabled");
  document.getElementById('menubut1').removeAttribute("class");
}

Menu.prototype.show = function() {
  document.getElementById('open').removeAttribute("style");
  document.getElementById('url1').focus();
  document.getElementById('sendbut1').setAttribute("disabled", "disabled");
  document.getElementById('menubut1').setAttribute("class", "active");
}

Menu.prototype.toggle = function() {
  if (this.isopen()) {
    menu.hide();
  } else {
    menu.show();
  }
}
menu = new Menu();

function guidisconnect() {
  lol('/disconnect');

}

function guiconnect() {
  menu.hide();
  var url = document.getElementById('url1').value;
  var proto = document.getElementById('proto1').value;
  lol('/connect ' + url + ' ' + proto);
}

function keypress() {
  if (event.keyCode == 13) {
    if (menu.isopen()) {
      if (isconnected()) {
        return true;
      }
      document.getElementById('conbut1').click()
    } else {
      document.getElementById('sendbut1').click()
    }
  } else if (event.keyIdentifier == 'U+001B') {
    if (typeof(ws.readyState) == typeof(undefined)) {
      menu.toggle();
    } else if (ws.readyState < 2) { // OPEN or CONNECTING
      guidisconnect();
    } else {
      menu.toggle();
    }
  }
}

function isconnected() {
  if (typeof(ws.readyState) == typeof(undefined)) {
    return false;
  }
  if (ws.readyState == 1) {
    return true;
  }
  return false;
}

function linkfix() {
  document.getElementById("sourcelink").setAttribute("href","view-source:"+location.href);
}

function parseParams() {
    var query = window.location.href.split('?')[1];
    if (query !== undefined) {
        var defs = query.split('&');
    }
    var params = {}
    for (var i in defs) {
        var parts = defs[i].split("=");
        params[parts[0]] = parts[1];
    }
    return params;
}

function init() {
  var params = parseParams();
  var connected = params.connected;
  var socket = params.socket;
  var proto = params.proto;

  linkfix();
  if (proto) {
      document.getElementById('proto1').value = proto
  }
  if (socket) {
      document.getElementById('url1').value = socket
  }
  refreshclock();
  document.getElementById('clock1').removeAttribute("style");
  setInterval( "refreshclock();", 500 );
  if (("WebSocket" in window) == false) {
    log('Your browser does not seem to support websockets.', 'error');
    return;
  }
  lol('/help');
  if(connected == "true")
  {
    document.getElementById('conbut1').click()
  }
  else
  {
    menu.show();
  }
}

</script>

<style>

body
{
  height: 100%;
  background-color: #540;
}
h1 a
{
  padding: 0;
  color: #000;
  font-family: serif;
}
.button
{
  width: 3em;
}
.direction
{
  width: 3em;
  text-align: right;
}

.sent
{
  color: #77c;
}

.received
{
  color: #c77;
}

.command
{
  color: #3ef;
}

.error
{
  color: #f00;
}

.system
{
  color: #7f7;
}

.time
{
  width: 3em;
}

.sec
{
  color: #777;
}

.label
{
  width: 1em;
}

.protofield
{
  width: 15%;
}

h1 a
{
  color: #aaa;
  font-family: sans-serif;
  text-decoration: none;

}

h1
{
  text-align: center;
}
.footer
{
  margin-top: 4em;
  text-align: center;
  font-size: 0.4em;
  font-family: sans-serif;
  color: #ddd;
  padding: 1em;
}

.footer a
{
  color: #ddf;
}
.footer img
{
  width: 5em;
  height: 1.8em;
  padding-right: 1em;
}

table.terminal
{
  background-color: #000;
  color: #ccc;
  font-family: monospace;
}
input[type="text"]
{
  background-color: #444;
  color: #fff;
  font-family: monospace;
  border: thin solid #f00;
}

input[readonly="readonly"]
{
  background-color: #555;
  color: #ddd;

}

#open input[type="text"]
{
  border: thin solid #000;
  width: 100%;
}
.bar2 input[type="text"]
{
  border: thin solid #000;
  width: 100%;
}

.consolebar input[type="button"]
{
  padding: 0;
  width: 5em;
}

body
{
  margin: 0;
}
.logline td
{
  vertical-align: top;
}
.preserved {
  white-space: pre;
}

.consolebar
{
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 2em;
  background-color: #222;
}

.consolebar .time
{
  font-family: monospace;
  width: 1em;
  color: #ddd;
}

.consolebar .leftpad
{
  padding-left: 1em;
}

.consolebar .rightpad
{
  padding-right: 1em;
}

#screen1
{
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 2em;
  background-color: #000;
  overflow: auto;
  vertical-align: top;
}

#open
{
  background-color: rgba(85, 68, 0, 0.8);
  color: #777;
  border-radius: 15px;
  position: absolute;
  margin: 10%;
  width: 80%;
  border: medium solid #777;
  text-align: center;
  font-family: sans-serif;
  font-size: 0.8em;
}
.bar2
{
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 2em;
}
.panel
{
  border: medium solid #540;
  border-radius: 5px;
  padding: 1em;
  margin: auto 10%;
  width: 80%;
  background-color: #320;
  text-align: right;
}
.panel .label
{
  width: 3em;
}
.binary
{
  color: #888;
}
</style>
</head>
<body onload="init();" onkeydown="keypress();">
<div id="screen1" class="screen">
<table id="ter1" class="terminal">
</table>
</div>
<div class="bar2">
<table class="consolebar"><tr>
<td id="clock1" style="color: transparent;" class="time rightpad leftpad">00:00:00</td>
<td><input id="msg1" type="text" value=""></td>
<td class="button rightpad"><input id="sendbut1" type="button" value="send" disabled="disabled" onClick="send();"></td>
<td class="button rightpad"><input id="menubut1" type="button" value="menu" onClick="menu.toggle();"></td>
</tr></table>
</div>

<div id="open" style="visibility: hidden;">
<h1><a href="?">Dark WebSocket Terminal</a></h1>
<table class="panel">
<tr><td class="label">socket:</td><td><input type="text" id="url1" value="ws://echo.websocket.org/"></td></tr>
<tr><td>protocol:</td><td><input type="text" id="proto1" value=""></td></tr>
<tr><td colspan="2"><input id="conbut1" type="button" value="connect" onClick="guiconnect();"></td></tr>
</table>

<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#" class="footer"> 
  <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/"> 
    <img src="http://i.creativecommons.org/l/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" /></a> 

  To the extent possible under law, <a id="sourcelink" href="" rel="dct:publisher"><span property="dct:title">Dark WebSocket Terminal developers</span></a> 
  have waived all copyright and related or neighboring rights to
  <span property="dct:title">Dark WebSocket Terminal</span>.
</p>
</div>
<input id="file1" type="file" style="visibility: hidden;"/>
</body>
</html>
